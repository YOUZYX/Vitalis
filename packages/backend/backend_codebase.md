# backend_codebase.md

```md
# package.json

\`\`\`json
{
    "name": "backend",
    "version": "0.1.0",
    "private": true,
    "scripts": {
        "dev": "tsx watch src/index.ts",
        "build": "tsc",
        "start": "node dist/index.js",
        "prisma:generate": "prisma generate",
        "prisma:migrate": "prisma migrate dev",
        "prisma:seed": "tsx prisma/seed.ts",
        "prisma:studio": "prisma studio"
    },
    "dependencies": {
        "@prisma/client": "^5.8.0",
        "@upstash/redis": "^1.28.0",
        "@upstash/vector": "^1.1.0",
        "fastify": "^4.25.0",
        "@fastify/cors": "^9.0.0",
        "@fastify/jwt": "^8.0.0",
        "ethers": "^6.9.0",
        "dotenv": "^16.3.0",
        "zod": "^3.22.0"
    },
    "devDependencies": {
        "prisma": "^5.8.0",
        "tsx": "^4.7.0",
        "typescript": "^5.3.0",
        "@types/node": "^20.0.0"
    }
}
\`\`\`

# prisma\migrations\20260215042909_init\migration.sql

\`\`\`sql
-- CreateEnum
CREATE TYPE "AgentRole" AS ENUM ('GUARDIAN', 'ARCHITECT', 'VALIDATOR', 'STRATEGIST', 'WORKER');

-- CreateEnum
CREATE TYPE "BountyStatus" AS ENUM ('OPEN', 'IN_PROGRESS', 'COMPLETED', 'EXPIRED');

-- CreateTable
CREATE TABLE "Agent" (
    "id" TEXT NOT NULL,
    "walletAddress" TEXT NOT NULL,
    "role" "AgentRole" NOT NULL,
    "vitality" INTEGER NOT NULL DEFAULT 100,
    "reputation" INTEGER NOT NULL DEFAULT 50,
    "isActive" BOOLEAN NOT NULL DEFAULT true,
    "lastPulseBlock" BIGINT NOT NULL DEFAULT 0,

    CONSTRAINT "Agent_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "Bounty" (
    "id" TEXT NOT NULL,
    "onChainId" TEXT NOT NULL,
    "title" TEXT NOT NULL,
    "description" TEXT NOT NULL,
    "rewardAmount" DECIMAL(65,30) NOT NULL,
    "status" "BountyStatus" NOT NULL DEFAULT 'OPEN',
    "creatorId" TEXT NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "Bounty_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "Submission" (
    "id" TEXT NOT NULL,
    "bountyId" TEXT NOT NULL,
    "agentId" TEXT NOT NULL,
    "contentUri" TEXT NOT NULL,
    "isApproved" BOOLEAN NOT NULL DEFAULT false,
    "timestamp" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "Submission_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "AgentLog" (
    "id" SERIAL NOT NULL,
    "agentId" TEXT NOT NULL,
    "reasoning" TEXT NOT NULL,
    "actionTaken" TEXT NOT NULL,
    "timestamp" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "AgentLog_pkey" PRIMARY KEY ("id")
);

-- CreateIndex
CREATE UNIQUE INDEX "Agent_walletAddress_key" ON "Agent"("walletAddress");

-- CreateIndex
CREATE UNIQUE INDEX "Bounty_onChainId_key" ON "Bounty"("onChainId");

-- AddForeignKey
ALTER TABLE "Bounty" ADD CONSTRAINT "Bounty_creatorId_fkey" FOREIGN KEY ("creatorId") REFERENCES "Agent"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Submission" ADD CONSTRAINT "Submission_bountyId_fkey" FOREIGN KEY ("bountyId") REFERENCES "Bounty"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Submission" ADD CONSTRAINT "Submission_agentId_fkey" FOREIGN KEY ("agentId") REFERENCES "Agent"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "AgentLog" ADD CONSTRAINT "AgentLog_agentId_fkey" FOREIGN KEY ("agentId") REFERENCES "Agent"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

\`\`\`

# prisma\migrations\migration_lock.toml

\`\`\`toml
# Please do not edit this file manually
# It should be added in your version-control system (i.e. Git)
provider = "postgresql"
\`\`\`

# prisma\schema.prisma

\`\`\`prisma
// schema.prisma â€” Canonical schema from Vitalis_Master_Spec.md Â§2
// DO NOT MODIFY without updating the Spec.

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

enum AgentRole {
  GUARDIAN    // Monitors System Health
  ARCHITECT   // Creates Bounties
  VALIDATOR   // Verifies Work & Pulses
  STRATEGIST  // Optimizes Global Params (The 4th Agent)
  WORKER      // External Agents (Users/Bots)
}

enum BountyStatus {
  OPEN
  IN_PROGRESS
  COMPLETED
  EXPIRED
}

model Agent {
  id              String      @id @default(uuid())
  walletAddress   String      @unique
  role            AgentRole
  vitality        Int         @default(100)
  reputation      Int         @default(50)
  isActive        Boolean     @default(true)
  lastPulseBlock  BigInt      @default(0)
  logs            AgentLog[]
  submissions     Submission[]
  createdBounties Bounty[]    @relation("CreatedBounties")
}

model Bounty {
  id              String       @id @default(uuid())
  onChainId       String       @unique // bytes32 from Solidity
  title           String
  description     String
  rewardAmount    Decimal      // In MON
  status          BountyStatus @default(OPEN)
  creatorId       String
  creator         Agent        @relation("CreatedBounties", fields: [creatorId], references: [id])
  submissions     Submission[]
  createdAt       DateTime     @default(now())
}

model Submission {
  id              String   @id @default(uuid())
  bountyId        String
  bounty          Bounty   @relation(fields: [bountyId], references: [id])
  agentId         String
  agent           Agent    @relation(fields: [agentId], references: [id])
  contentUri      String   // IPFS or URL
  isApproved      Boolean  @default(false)
  timestamp       DateTime @default(now())
}

model AgentLog {
  id              Int      @id @default(autoincrement())
  agentId         String
  agent           Agent    @relation(fields: [agentId], references: [id])
  reasoning       String   @db.Text
  actionTaken     String
  timestamp       DateTime @default(now())
}

\`\`\`

# prisma\seed.ts

\`\`\`ts
/**
 * Prisma Seed Script â€” Insert System Agents
 *
 * Creates the 4 Core Agents + 1 Worker:
 *   1. Guardian   â€” Ecosystem health monitor
 *   2. Architect  â€” Bounty creator
 *   3. Validator  â€” Submission verifier
 *   4. Strategist â€” Metabolism optimizer
 *   5. Worker     â€” Demo external agent
 */

import { PrismaClient } from "@prisma/client";
import dotenv from "dotenv";

dotenv.config({ path: "../../.env" });
dotenv.config({ path: "../../.env.local" });

const prisma = new PrismaClient();

async function main() {
    console.log("ğŸŒ± Seeding Vitalis database...\n");

    // Use the deployer wallet as the system agent address base
    // In production, each agent would have its own wallet
    const DEPLOYER = process.env.WALLET_PRIVATE_KEY
        ? "deployer" // Will be derived below
        : "0x0000000000000000000000000000000000000000";

    // Create deterministic addresses for system agents
    // For MVP, we use the deployer address for all system agents
    // In production, each has its own key pair
    const systemAgents = [
        {
            walletAddress: "0x0000000000000000000000000000000000000001",
            role: "GUARDIAN" as const,
            vitality: 100,
            reputation: 100,
        },
        {
            walletAddress: "0x0000000000000000000000000000000000000002",
            role: "ARCHITECT" as const,
            vitality: 100,
            reputation: 100,
        },
        {
            walletAddress: "0x0000000000000000000000000000000000000003",
            role: "VALIDATOR" as const,
            vitality: 100,
            reputation: 100,
        },
        {
            walletAddress: "0x0000000000000000000000000000000000000004",
            role: "STRATEGIST" as const,
            vitality: 100,
            reputation: 100,
        },
        {
            walletAddress: "0x0000000000000000000000000000000000000005",
            role: "WORKER" as const,
            vitality: 100,
            reputation: 50,
        },
    ];

    for (const agent of systemAgents) {
        const result = await prisma.agent.upsert({
            where: { walletAddress: agent.walletAddress },
            update: {},
            create: {
                walletAddress: agent.walletAddress,
                role: agent.role,
                vitality: agent.vitality,
                reputation: agent.reputation,
                isActive: true,
                lastPulseBlock: BigInt(0),
            },
        });

        console.log(`  âœ… ${agent.role.padEnd(12)} â€” ${result.id} (${agent.walletAddress})`);
    }

    // Create initial logs for each system agent
    const agents = await prisma.agent.findMany({
        where: {
            role: { in: ["GUARDIAN", "ARCHITECT", "VALIDATOR", "STRATEGIST"] },
        },
    });

    for (const agent of agents) {
        await prisma.agentLog.create({
            data: {
                agentId: agent.id,
                reasoning: `${agent.role} agent initialized. Standing by.`,
                actionTaken: "system_boot",
            },
        });
    }

    console.log("\n  ğŸ“‹ Created initial boot logs for all system agents");
    console.log("\nğŸŒ± Seed complete!\n");
}

main()
    .catch((e) => {
        console.error("Seed failed:", e);
        process.exit(1);
    })
    .finally(async () => {
        await prisma.$disconnect();
    });

\`\`\`

# src\index.ts

\`\`\`ts
/**
 * Vitalis Backend â€” Main Entry Point
 *
 * Fastify server with:
 * - JWT auth (via @fastify/jwt)
 * - CORS configured for localhost:3000
 * - All API routes registered
 * - Blockchain service initialized
 */

import Fastify from "fastify";
import cors from "@fastify/cors";
import jwt from "@fastify/jwt";
import dotenv from "dotenv";

// Load env from root
dotenv.config({ path: "../../.env" });
dotenv.config({ path: "../../.env.local" });

import { initBlockchain } from "./services/blockchain";
import { authRoutes } from "./routes/auth";
import { bountyRoutes } from "./routes/bounties";
import { submissionRoutes } from "./routes/submissions";
import { agentLogRoutes } from "./routes/agent-logs";
import { agentActionRoutes } from "./routes/agent-actions";

// â”€â”€â”€ Create Fastify App â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

const app = Fastify({
    logger: true,
});

// â”€â”€â”€ Plugins â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// CORS â€” allow frontend at localhost:3000
app.register(cors, {
    origin: ["http://localhost:3000", "http://localhost:3001"],
    credentials: true,
});

// JWT â€” for issuing and verifying auth tokens
app.register(jwt, {
    secret: process.env.JWT_SECRET || "vitalis-dev-secret-change-in-production",
});

// â”€â”€â”€ Auth Decorator â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// Decorate fastify instance with an `authenticate` method
app.decorate("authenticate", async function (request: any, reply: any) {
    try {
        await request.jwtVerify();
    } catch (err) {
        reply.code(401).send({ error: "Unauthorized" });
    }
});

// â”€â”€â”€ Health Check â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

app.get("/health", async () => {
    return {
        status: "ok",
        service: "vitalis-backend",
        timestamp: new Date().toISOString(),
    };
});

// â”€â”€â”€ Register Route Groups â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

app.register(authRoutes, { prefix: "/auth" });
app.register(bountyRoutes, { prefix: "/bounties" });
app.register(submissionRoutes, { prefix: "/submissions" });
app.register(agentLogRoutes, { prefix: "/agent-logs" });
app.register(agentActionRoutes, { prefix: "/agent" });

// â”€â”€â”€ Start Server â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

const start = async () => {
    try {
        // Initialize blockchain service
        initBlockchain();

        const port = parseInt(process.env.PORT || "3001", 10);
        await app.listen({ port, host: "0.0.0.0" });

        console.log("");
        console.log("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
        console.log("â•‘     ğŸ§¬ VITALIS BACKEND v0.1.0           â•‘");
        console.log(`â•‘     Port: ${port}                          â•‘`);
        console.log("â•‘     Chain: Monad Testnet (10143)         â•‘");
        console.log("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
    } catch (err) {
        app.log.error(err);
        process.exit(1);
    }
};

start();

\`\`\`

# src\lib\prisma.ts

\`\`\`ts
import { PrismaClient } from "@prisma/client";

// Singleton Prisma client
const prisma = new PrismaClient({
    log: process.env.NODE_ENV === "development" ? ["query", "warn", "error"] : ["warn", "error"],
});

export default prisma;

\`\`\`

# src\routes\agent-actions.ts

\`\`\`ts
/**
 * Agent Action Routes
 *
 * POST /agent/action â€” Endpoint for AI agents to request on-chain actions.
 * Mediates between agent decision-making and the deployer wallet.
 */

import { FastifyInstance } from "fastify";
import { z } from "zod";
import prisma from "../lib/prisma";
import {
    createBountyOnChain,
    approveSubmissionOnChain,
    pruneAgent,
    updateMetabolicParams,
    getVitality,
    getMetabolicParams,
} from "../services/blockchain";
import { broadcastLog } from "./agent-logs";

const actionSchema = z.discriminatedUnion("action", [
    z.object({
        action: z.literal("get_ecosystem_health"),
        agentId: z.string(),
        params: z.object({
            threshold: z.number().int().default(20),
        }),
    }),
    z.object({
        action: z.literal("create_bounty"),
        agentId: z.string(),
        params: z.object({
            title: z.string(),
            rewardMON: z.string(),
            requirements: z.string(),
        }),
    }),
    z.object({
        action: z.literal("validate_and_pulse"),
        agentId: z.string(),
        params: z.object({
            bountyId: z.string(),
            submissionId: z.string(),
            verdict: z.boolean(),
            reasoning: z.string().optional(),
        }),
    }),
    z.object({
        action: z.literal("optimize_metabolism"),
        agentId: z.string(),
        params: z.object({
            newDecayRate: z.number().int(),
            reasoning: z.string().optional(),
        }),
    }),
    z.object({
        action: z.literal("prune_agent"),
        agentId: z.string(),
        params: z.object({
            targetAddress: z.string(),
        }),
    }),
]);

export async function agentActionRoutes(app: FastifyInstance) {
    /**
     * POST /agent/action
     *
     * Central endpoint for AI agents to execute on-chain actions.
     * The backend wallet mediates all chain interactions.
     */
    app.post("/action", async (request, reply) => {
        try {
            const body = actionSchema.parse(request.body);
            let result: any;
            let logReasoning = "";
            let logAction = "";

            switch (body.action) {
                // â”€â”€â”€ Guardian: Get Ecosystem Health â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                case "get_ecosystem_health": {
                    const agents = await prisma.agent.findMany({
                        where: { isActive: true },
                    });

                    const healthData = await Promise.all(
                        agents.map(async (agent) => {
                            const vitality = await getVitality(agent.walletAddress);
                            return {
                                agentId: agent.id,
                                walletAddress: agent.walletAddress,
                                role: agent.role,
                                vitality: Number(vitality),
                                atRisk: Number(vitality) < body.params.threshold,
                            };
                        })
                    );

                    const avgVitality =
                        healthData.reduce((sum, a) => sum + a.vitality, 0) / healthData.length || 0;
                    const atRisk = healthData.filter((a) => a.atRisk);

                    result = {
                        averageVitality: Math.round(avgVitality),
                        totalAgents: healthData.length,
                        agentsAtRisk: atRisk.length,
                        atRiskAgents: atRisk,
                        allAgents: healthData,
                    };

                    logReasoning = `Ecosystem health check (threshold: ${body.params.threshold})`;
                    logAction = `get_ecosystem_health â†’ avg: ${Math.round(avgVitality)}, at risk: ${atRisk.length}`;
                    break;
                }

                // â”€â”€â”€ Architect: Create Bounty â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                case "create_bounty": {
                    const metadataURI = `vitalis://${body.params.title}`;
                    const { txHash, bountyId } = await createBountyOnChain(
                        metadataURI,
                        body.params.rewardMON
                    );

                    // Store in DB
                    const bounty = await prisma.bounty.create({
                        data: {
                            onChainId: bountyId,
                            title: body.params.title,
                            description: body.params.requirements,
                            rewardAmount: parseFloat(body.params.rewardMON),
                            status: "OPEN",
                            creatorId: body.agentId,
                        },
                    });

                    result = { bounty, txHash, onChainId: bountyId };
                    logReasoning = `Created bounty: ${body.params.title} (${body.params.rewardMON} MON)`;
                    logAction = `create_bounty(${bountyId}) â€” tx: ${txHash}`;
                    break;
                }

                // â”€â”€â”€ Validator: Validate & Pulse â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                case "validate_and_pulse": {
                    const submission = await prisma.submission.findUnique({
                        where: { id: body.params.submissionId },
                        include: {
                            bounty: true,
                            agent: true,
                        },
                    });

                    if (!submission) {
                        return reply.code(404).send({ error: "Submission not found" });
                    }

                    if (body.params.verdict) {
                        // Approve on-chain
                        const { txHash } = await approveSubmissionOnChain(
                            submission.bounty.onChainId,
                            submission.agent.walletAddress
                        );

                        // Update DB
                        await prisma.submission.update({
                            where: { id: body.params.submissionId },
                            data: { isApproved: true },
                        });

                        await prisma.bounty.update({
                            where: { id: submission.bountyId },
                            data: { status: "COMPLETED" },
                        });

                        // Update agent vitality in DB (sync with chain)
                        const newVitality = await getVitality(submission.agent.walletAddress);
                        await prisma.agent.update({
                            where: { id: submission.agentId },
                            data: { vitality: Number(newVitality) },
                        });

                        result = { approved: true, txHash };
                        logAction = `validate_and_pulse(${body.params.bountyId}, APPROVED) â€” tx: ${txHash}`;
                    } else {
                        result = { approved: false };
                        logAction = `validate_and_pulse(${body.params.bountyId}, REJECTED)`;
                    }

                    logReasoning = body.params.reasoning || `Validated submission ${body.params.submissionId}`;
                    break;
                }

                // â”€â”€â”€ Strategist: Optimize Metabolism â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                case "optimize_metabolism": {
                    const currentParams = await getMetabolicParams();
                    const { txHash } = await updateMetabolicParams(
                        body.params.newDecayRate,
                        currentParams.pulseAmount
                    );

                    result = {
                        previousDecayRate: currentParams.decayRate,
                        newDecayRate: body.params.newDecayRate,
                        txHash,
                    };

                    logReasoning = body.params.reasoning || `Adjusted decay rate to ${body.params.newDecayRate}`;
                    logAction = `optimize_metabolism(${body.params.newDecayRate}) â€” tx: ${txHash}`;
                    break;
                }

                // â”€â”€â”€ Prune Agent â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                case "prune_agent": {
                    const { txHash } = await pruneAgent(body.params.targetAddress);

                    // Update DB
                    await prisma.agent.updateMany({
                        where: { walletAddress: body.params.targetAddress.toLowerCase() },
                        data: { isActive: false, vitality: 0 },
                    });

                    result = { pruned: true, txHash };
                    logReasoning = `Pruned agent ${body.params.targetAddress}`;
                    logAction = `prune_agent(${body.params.targetAddress}) â€” tx: ${txHash}`;
                    break;
                }
            }

            // Log the agent action
            const log = await prisma.agentLog.create({
                data: {
                    agentId: body.agentId,
                    reasoning: logReasoning,
                    actionTaken: logAction,
                },
                include: {
                    agent: { select: { role: true } },
                },
            });

            // Broadcast to SSE clients
            broadcastLog({
                id: log.id,
                agentId: log.agentId,
                reasoning: log.reasoning,
                actionTaken: log.actionTaken,
                timestamp: log.timestamp,
                agentRole: log.agent.role,
            });

            return reply.send({ success: true, action: body.action, result });
        } catch (error: any) {
            return reply.code(400).send({
                error: "Agent action failed",
                message: error.message,
            });
        }
    });

    /**
     * GET /agent/status
     * Public â€” get system-wide agent status overview.
     */
    app.get("/status", async (request, reply) => {
        const agents = await prisma.agent.findMany({
            include: {
                _count: {
                    select: { logs: true, submissions: true },
                },
            },
        });

        const metabolicParams = await getMetabolicParams().catch(() => ({
            decayRate: 1000,
            pulseAmount: 50,
        }));

        return reply.send({
            agents,
            metabolicParams,
            totalAgents: agents.length,
            activeAgents: agents.filter((a) => a.isActive).length,
        });
    });
}

\`\`\`

# src\routes\agent-logs.ts

\`\`\`ts
/**
 * Agent Log Routes â€” including SSE real-time stream
 *
 * GET  /agent-logs         â€” Paginated list
 * GET  /agent-logs/stream  â€” Server-Sent Events for real-time logs
 */

import { FastifyInstance } from "fastify";
import prisma from "../lib/prisma";

// â”€â”€â”€ In-memory subscriber list for SSE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

type SSEClient = {
    id: string;
    reply: any;
};

const sseClients: SSEClient[] = [];

/**
 * Push a new log to all connected SSE clients.
 * Call this from any route/service that creates an AgentLog.
 */
export function broadcastLog(log: {
    id: number;
    agentId: string;
    reasoning: string;
    actionTaken: string;
    timestamp: Date;
    agentRole?: string;
}) {
    const data = JSON.stringify(log);
    for (let i = sseClients.length - 1; i >= 0; i--) {
        try {
            sseClients[i].reply.raw.write(`data: ${data}\n\n`);
        } catch {
            // Client disconnected â€” remove
            sseClients.splice(i, 1);
        }
    }
}

export async function agentLogRoutes(app: FastifyInstance) {
    /**
     * GET /agent-logs
     * Public â€” paginated agent logs.
     */
    app.get("/", async (request, reply) => {
        const { limit = "50", offset = "0", agentId } = request.query as {
            limit?: string;
            offset?: string;
            agentId?: string;
        };

        const where = agentId ? { agentId } : {};

        const [logs, total] = await Promise.all([
            prisma.agentLog.findMany({
                where,
                include: {
                    agent: {
                        select: { id: true, walletAddress: true, role: true },
                    },
                },
                orderBy: { timestamp: "desc" },
                take: parseInt(limit),
                skip: parseInt(offset),
            }),
            prisma.agentLog.count({ where }),
        ]);

        return reply.send({ logs, total, limit: parseInt(limit), offset: parseInt(offset) });
    });

    /**
     * GET /agent-logs/stream
     * Server-Sent Events (SSE) â€” push new logs in real-time.
     *
     * Frontend connects via:
     *   const es = new EventSource("http://localhost:3001/agent-logs/stream");
     *   es.onmessage = (e) => { const log = JSON.parse(e.data); ... }
     */
    app.get("/stream", async (request, reply) => {
        const clientId = Math.random().toString(36).substring(7);

        // Set SSE headers
        reply.raw.writeHead(200, {
            "Content-Type": "text/event-stream",
            "Cache-Control": "no-cache",
            Connection: "keep-alive",
            "Access-Control-Allow-Origin": "*",
        });

        // Send initial connection event
        reply.raw.write(`data: ${JSON.stringify({ type: "connected", clientId })}\n\n`);

        // Send recent logs as initial payload
        const recentLogs = await prisma.agentLog.findMany({
            include: {
                agent: {
                    select: { role: true },
                },
            },
            orderBy: { timestamp: "desc" },
            take: 20,
        });

        for (const log of recentLogs.reverse()) {
            reply.raw.write(
                `data: ${JSON.stringify({
                    ...log,
                    agentRole: log.agent.role,
                })}\n\n`
            );
        }

        // Register this client
        sseClients.push({ id: clientId, reply });

        // Handle disconnect
        request.raw.on("close", () => {
            const index = sseClients.findIndex((c) => c.id === clientId);
            if (index !== -1) sseClients.splice(index, 1);
        });

        // Keep alive â€” ping every 30s
        const keepAlive = setInterval(() => {
            try {
                reply.raw.write(`: keepalive\n\n`);
            } catch {
                clearInterval(keepAlive);
            }
        }, 30_000);

        request.raw.on("close", () => clearInterval(keepAlive));
    });
}

\`\`\`

# src\routes\auth.ts

\`\`\`ts
/**
 * Auth Routes â€” Privy + JWT
 *
 * POST /auth/verify â€” Verify Privy auth token and issue backend JWT.
 */

import { FastifyInstance } from "fastify";
import { z } from "zod";
import prisma from "../lib/prisma";

const verifySchema = z.object({
    walletAddress: z.string().regex(/^0x[a-fA-F0-9]{40}$/),
    privyToken: z.string().min(1),
});

export async function authRoutes(app: FastifyInstance) {
    /**
     * POST /auth/verify
     *
     * Verifies a Privy auth token + wallet address.
     * Returns a signed JWT for use in subsequent API calls.
     * Auto-creates a WORKER agent in DB if not exists.
     */
    app.post("/verify", async (request, reply) => {
        try {
            const body = verifySchema.parse(request.body);
            const { walletAddress, privyToken } = body;

            // In production: verify privyToken against Privy API
            // For MVP: we trust the frontend's Privy-authenticated wallet
            // TODO: Add Privy server-side verification when APP_SECRET is available

            // Upsert agent in DB (create as WORKER if new)
            let agent = await prisma.agent.findUnique({
                where: { walletAddress: walletAddress.toLowerCase() },
            });

            if (!agent) {
                agent = await prisma.agent.create({
                    data: {
                        walletAddress: walletAddress.toLowerCase(),
                        role: "WORKER",
                        vitality: 100,
                        reputation: 50,
                        isActive: true,
                        lastPulseBlock: BigInt(0),
                    },
                });
            }

            // Sign a JWT with agent info
            const token = app.jwt.sign(
                {
                    agentId: agent.id,
                    walletAddress: agent.walletAddress,
                    role: agent.role,
                },
                { expiresIn: "24h" }
            );

            return reply.send({
                token,
                agent: {
                    id: agent.id,
                    walletAddress: agent.walletAddress,
                    role: agent.role,
                    vitality: agent.vitality,
                    reputation: agent.reputation,
                    isActive: agent.isActive,
                },
            });
        } catch (error: any) {
            return reply.code(400).send({
                error: "Authentication failed",
                message: error.message,
            });
        }
    });
}

\`\`\`

# src\routes\bounties.ts

\`\`\`ts
/**
 * Bounty Routes â€” CRUD
 *
 * GET  /bounties     â€” List all bounties
 * POST /bounties     â€” Create a new bounty (on-chain + DB)
 */

import { FastifyInstance } from "fastify";
import { z } from "zod";
import prisma from "../lib/prisma";
import { createBountyOnChain } from "../services/blockchain";

const createBountySchema = z.object({
    title: z.string().min(1).max(200),
    description: z.string().min(1),
    rewardMON: z.string().regex(/^\d+\.?\d*$/), // String representation of MON amount
    metadataURI: z.string().optional(),
});

export async function bountyRoutes(app: FastifyInstance) {
    /**
     * GET /bounties
     * Public â€” lists all bounties with creator info.
     */
    app.get("/", async (request, reply) => {
        const bounties = await prisma.bounty.findMany({
            include: {
                creator: {
                    select: {
                        id: true,
                        walletAddress: true,
                        role: true,
                    },
                },
                _count: {
                    select: { submissions: true },
                },
            },
            orderBy: { createdAt: "desc" },
        });

        return reply.send({ bounties });
    });

    /**
     * GET /bounties/:id
     * Public â€” get a single bounty with submissions.
     */
    app.get("/:id", async (request, reply) => {
        const { id } = request.params as { id: string };

        const bounty = await prisma.bounty.findUnique({
            where: { id },
            include: {
                creator: {
                    select: { id: true, walletAddress: true, role: true },
                },
                submissions: {
                    include: {
                        agent: {
                            select: { id: true, walletAddress: true, role: true },
                        },
                    },
                },
            },
        });

        if (!bounty) {
            return reply.code(404).send({ error: "Bounty not found" });
        }

        return reply.send({ bounty });
    });

    /**
     * POST /bounties
     * Authenticated â€” creates bounty on-chain then stores in DB.
     */
    app.post("/", {
        preHandler: [app.authenticate],
    }, async (request, reply) => {
        try {
            const body = createBountySchema.parse(request.body);
            const user = request.user as { agentId: string; walletAddress: string };

            // 1. Deploy on-chain
            const metadataURI = body.metadataURI || `vitalis://${body.title}`;
            const { txHash, bountyId } = await createBountyOnChain(metadataURI, body.rewardMON);

            if (!bountyId) {
                return reply.code(500).send({ error: "Failed to extract bountyId from chain" });
            }

            // 2. Store in DB
            const bounty = await prisma.bounty.create({
                data: {
                    onChainId: bountyId,
                    title: body.title,
                    description: body.description,
                    rewardAmount: parseFloat(body.rewardMON),
                    status: "OPEN",
                    creatorId: user.agentId,
                },
            });

            // 3. Log the action
            await prisma.agentLog.create({
                data: {
                    agentId: user.agentId,
                    reasoning: `Created bounty: ${body.title}`,
                    actionTaken: `createBounty(${bountyId}) â€” tx: ${txHash}`,
                },
            });

            return reply.code(201).send({ bounty, txHash, onChainId: bountyId });
        } catch (error: any) {
            return reply.code(400).send({
                error: "Failed to create bounty",
                message: error.message,
            });
        }
    });
}

\`\`\`

# src\routes\submissions.ts

\`\`\`ts
/**
 * Submission Routes
 *
 * POST /submissions â€” Submit work to a bounty.
 */

import { FastifyInstance } from "fastify";
import { z } from "zod";
import prisma from "../lib/prisma";

const submitSchema = z.object({
    bountyId: z.string().uuid(),
    contentUri: z.string().min(1),
});

export async function submissionRoutes(app: FastifyInstance) {
    /**
     * POST /submissions
     * Authenticated â€” submit work for a bounty.
     */
    app.post("/", {
        preHandler: [app.authenticate],
    }, async (request, reply) => {
        try {
            const body = submitSchema.parse(request.body);
            const user = request.user as { agentId: string };

            // Check bounty exists and is OPEN
            const bounty = await prisma.bounty.findUnique({
                where: { id: body.bountyId },
            });

            if (!bounty) {
                return reply.code(404).send({ error: "Bounty not found" });
            }

            if (bounty.status !== "OPEN" && bounty.status !== "IN_PROGRESS") {
                return reply.code(400).send({ error: "Bounty is not accepting submissions" });
            }

            // Create submission
            const submission = await prisma.submission.create({
                data: {
                    bountyId: body.bountyId,
                    agentId: user.agentId,
                    contentUri: body.contentUri,
                },
            });

            // Update bounty status to IN_PROGRESS
            await prisma.bounty.update({
                where: { id: body.bountyId },
                data: { status: "IN_PROGRESS" },
            });

            // Log the action
            await prisma.agentLog.create({
                data: {
                    agentId: user.agentId,
                    reasoning: `Submitted work for bounty ${bounty.title}`,
                    actionTaken: `submitWork(${body.bountyId})`,
                },
            });

            return reply.code(201).send({ submission });
        } catch (error: any) {
            return reply.code(400).send({
                error: "Failed to create submission",
                message: error.message,
            });
        }
    });

    /**
     * GET /submissions?bountyId=xxx
     * Public â€” list submissions for a bounty.
     */
    app.get("/", async (request, reply) => {
        const { bountyId } = request.query as { bountyId?: string };

        const where = bountyId ? { bountyId } : {};

        const submissions = await prisma.submission.findMany({
            where,
            include: {
                agent: {
                    select: { id: true, walletAddress: true, role: true },
                },
                bounty: {
                    select: { id: true, title: true, status: true },
                },
            },
            orderBy: { timestamp: "desc" },
        });

        return reply.send({ submissions });
    });
}

\`\`\`

# src\services\blockchain.ts

\`\`\`ts
/**
 * Blockchain Service â€” ethers v6 wrapper for Vitalis contracts
 *
 * Reads deployed addresses from contracts/deployments.json.
 * Reads ABIs from contract artifacts.
 * Provides typed functions: getVitality, createBounty, approveSubmission.
 */

import { ethers, JsonRpcProvider, Wallet, Contract } from "ethers";
import * as deployments from "../../../contracts/deployments.json";

// â”€â”€â”€ ABI Imports (only the function fragments we need) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

const REGISTRY_ABI = [
    "function getVitality(address agent) view returns (int256)",
    "function pulse(address agent)",
    "function prune(address agent)",
    "function registerAgent(address agent)",
    "function updateMetabolicParams(uint256 _decayRate, uint256 _pulseAmount)",
    "function setBountyContract(address _bountyContract)",
    "function setStrategist(address _strategist)",
    "function decayRate() view returns (uint256)",
    "function pulseAmount() view returns (uint256)",
    "function agents(address) view returns (int256 storedVitality, uint256 lastUpdateBlock, bool isActive, bool isRegistered)",
    "event VitalityPulse(address indexed agent, uint256 newAmount)",
    "event AgentPruned(address indexed agent)",
    "event ParametersUpdated(uint256 newDecayRate, uint256 newPulseAmount)",
    "event AgentRegistered(address indexed agent, int256 initialVitality)",
];

const BOUNTY_ABI = [
    "function createBounty(string metadataURI) payable returns (bytes32)",
    "function approveSubmission(bytes32 bountyId, address worker)",
    "function getBounty(bytes32 bountyId) view returns (address creator, string metadataURI, uint256 reward, bool isActive, bool isCompleted)",
    "function addApprover(address _approver)",
    "function removeApprover(address _approver)",
    "function bountyCount() view returns (uint256)",
    "event BountyCreated(bytes32 indexed bountyId, uint256 reward)",
    "event SubmissionApproved(bytes32 indexed bountyId, address indexed worker)",
];

// â”€â”€â”€ Contract Addresses â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

const REGISTRY_ADDRESS = deployments.contracts.VitalityRegistry;
const BOUNTY_ADDRESS = deployments.contracts.VitalisBounty;

// â”€â”€â”€ Provider & Wallet Setup â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

const RPC_URL = process.env.MONAD_RPC_URL || "https://testnet-rpc.monad.xyz";
const PRIVATE_KEY = process.env.WALLET_PRIVATE_KEY || "";

let provider: JsonRpcProvider;
let wallet: Wallet;
let registryContract: Contract;
let bountyContract: Contract;

export function initBlockchain() {
    provider = new JsonRpcProvider(RPC_URL);
    wallet = new Wallet(PRIVATE_KEY, provider);

    registryContract = new Contract(REGISTRY_ADDRESS, REGISTRY_ABI, wallet);
    bountyContract = new Contract(BOUNTY_ADDRESS, BOUNTY_ABI, wallet);

    console.log(`â›“ï¸  Blockchain service initialized`);
    console.log(`   Registry: ${REGISTRY_ADDRESS}`);
    console.log(`   Bounty:   ${BOUNTY_ADDRESS}`);
    console.log(`   Wallet:   ${wallet.address}`);
}

// â”€â”€â”€ Registry Functions â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

export async function getVitality(agentAddress: string): Promise<bigint> {
    return registryContract.getVitality(agentAddress);
}

export async function getAgentData(agentAddress: string) {
    const data = await registryContract.agents(agentAddress);
    return {
        storedVitality: data.storedVitality as bigint,
        lastUpdateBlock: data.lastUpdateBlock as bigint,
        isActive: data.isActive as boolean,
        isRegistered: data.isRegistered as boolean,
    };
}

export async function registerAgent(agentAddress: string) {
    const tx = await registryContract.registerAgent(agentAddress);
    const receipt = await tx.wait();
    return { txHash: tx.hash, receipt };
}

export async function pruneAgent(agentAddress: string) {
    const tx = await registryContract.prune(agentAddress);
    const receipt = await tx.wait();
    return { txHash: tx.hash, receipt };
}

export async function getMetabolicParams() {
    const [decayRate, pulseAmount] = await Promise.all([
        registryContract.decayRate(),
        registryContract.pulseAmount(),
    ]);
    return {
        decayRate: Number(decayRate),
        pulseAmount: Number(pulseAmount),
    };
}

export async function updateMetabolicParams(decayRate: number, pulseAmount: number) {
    const tx = await registryContract.updateMetabolicParams(decayRate, pulseAmount);
    const receipt = await tx.wait();
    return { txHash: tx.hash, receipt };
}

// â”€â”€â”€ Bounty Functions â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

export async function createBountyOnChain(metadataURI: string, rewardMON: string) {
    const tx = await bountyContract.createBounty(metadataURI, {
        value: ethers.parseEther(rewardMON),
    });
    const receipt = await tx.wait();

    // Extract bountyId from event
    let bountyId: string = "";
    for (const log of receipt.logs) {
        try {
            const parsed = bountyContract.interface.parseLog({
                topics: log.topics as string[],
                data: log.data,
            });
            if (parsed && parsed.name === "BountyCreated") {
                bountyId = parsed.args[0];
                break;
            }
        } catch {
            // Not our event
        }
    }

    return { txHash: tx.hash, bountyId, receipt };
}

export async function approveSubmissionOnChain(bountyId: string, workerAddress: string) {
    const tx = await bountyContract.approveSubmission(bountyId, workerAddress);
    const receipt = await tx.wait();
    return { txHash: tx.hash, receipt };
}

export async function getBountyOnChain(bountyId: string) {
    const data = await bountyContract.getBounty(bountyId);
    return {
        creator: data[0] as string,
        metadataURI: data[1] as string,
        reward: ethers.formatEther(data[2]),
        isActive: data[3] as boolean,
        isCompleted: data[4] as boolean,
    };
}

// â”€â”€â”€ Utility â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

export function getProvider() {
    return provider;
}

export function getWallet() {
    return wallet;
}

export function getWalletAddress() {
    return wallet.address;
}

export { REGISTRY_ADDRESS, BOUNTY_ADDRESS };

\`\`\`

# src\types\fastify.d.ts

\`\`\`ts
import "fastify";

declare module "fastify" {
    interface FastifyInstance {
        authenticate: (request: any, reply: any) => Promise<void>;
    }

    interface FastifyRequest {
        user: {
            agentId: string;
            walletAddress: string;
            role: string;
        };
    }
}

\`\`\`

# tsconfig.json

\`\`\`json
{
    "compilerOptions": {
        "target": "ES2020",
        "module": "commonjs",
        "lib": [
            "ES2020"
        ],
        "outDir": "./dist",
        "rootDir": "./src",
        "strict": true,
        "esModuleInterop": true,
        "forceConsistentCasingInFileNames": true,
        "skipLibCheck": true,
        "resolveJsonModule": true,
        "declaration": true,
        "declarationMap": true,
        "sourceMap": true
    },
    "include": [
        "src/**/*"
    ],
    "exclude": [
        "node_modules",
        "dist"
    ]
}
\`\`\`


```

# package.json

```json
{
    "name": "backend",
    "version": "0.1.0",
    "private": true,
    "scripts": {
        "dev": "tsx watch src/index.ts",
        "build": "tsc",
        "start": "node dist/index.js",
        "prisma:generate": "prisma generate",
        "prisma:migrate": "prisma migrate dev",
        "prisma:seed": "tsx prisma/seed.ts",
        "prisma:studio": "prisma studio"
    },
    "dependencies": {
        "@prisma/client": "^5.8.0",
        "@upstash/redis": "^1.28.0",
        "@upstash/vector": "^1.1.0",
        "fastify": "^4.25.0",
        "@fastify/cors": "^9.0.0",
        "@fastify/jwt": "^8.0.0",
        "ethers": "^6.9.0",
        "dotenv": "^16.3.0",
        "zod": "^3.22.0"
    },
    "devDependencies": {
        "prisma": "^5.8.0",
        "tsx": "^4.7.0",
        "typescript": "^5.3.0",
        "@types/node": "^20.0.0"
    },
    "prisma": {
        "seed": "tsx prisma/seed.ts"
    }
}
```

# prisma\migrations\20260215042909_init\migration.sql

```sql
-- CreateEnum
CREATE TYPE "AgentRole" AS ENUM ('GUARDIAN', 'ARCHITECT', 'VALIDATOR', 'STRATEGIST', 'WORKER');

-- CreateEnum
CREATE TYPE "BountyStatus" AS ENUM ('OPEN', 'IN_PROGRESS', 'COMPLETED', 'EXPIRED');

-- CreateTable
CREATE TABLE "Agent" (
    "id" TEXT NOT NULL,
    "walletAddress" TEXT NOT NULL,
    "role" "AgentRole" NOT NULL,
    "vitality" INTEGER NOT NULL DEFAULT 100,
    "reputation" INTEGER NOT NULL DEFAULT 50,
    "isActive" BOOLEAN NOT NULL DEFAULT true,
    "lastPulseBlock" BIGINT NOT NULL DEFAULT 0,

    CONSTRAINT "Agent_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "Bounty" (
    "id" TEXT NOT NULL,
    "onChainId" TEXT NOT NULL,
    "title" TEXT NOT NULL,
    "description" TEXT NOT NULL,
    "rewardAmount" DECIMAL(65,30) NOT NULL,
    "status" "BountyStatus" NOT NULL DEFAULT 'OPEN',
    "creatorId" TEXT NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "Bounty_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "Submission" (
    "id" TEXT NOT NULL,
    "bountyId" TEXT NOT NULL,
    "agentId" TEXT NOT NULL,
    "contentUri" TEXT NOT NULL,
    "isApproved" BOOLEAN NOT NULL DEFAULT false,
    "timestamp" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "Submission_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "AgentLog" (
    "id" SERIAL NOT NULL,
    "agentId" TEXT NOT NULL,
    "reasoning" TEXT NOT NULL,
    "actionTaken" TEXT NOT NULL,
    "timestamp" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "AgentLog_pkey" PRIMARY KEY ("id")
);

-- CreateIndex
CREATE UNIQUE INDEX "Agent_walletAddress_key" ON "Agent"("walletAddress");

-- CreateIndex
CREATE UNIQUE INDEX "Bounty_onChainId_key" ON "Bounty"("onChainId");

-- AddForeignKey
ALTER TABLE "Bounty" ADD CONSTRAINT "Bounty_creatorId_fkey" FOREIGN KEY ("creatorId") REFERENCES "Agent"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Submission" ADD CONSTRAINT "Submission_bountyId_fkey" FOREIGN KEY ("bountyId") REFERENCES "Bounty"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Submission" ADD CONSTRAINT "Submission_agentId_fkey" FOREIGN KEY ("agentId") REFERENCES "Agent"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "AgentLog" ADD CONSTRAINT "AgentLog_agentId_fkey" FOREIGN KEY ("agentId") REFERENCES "Agent"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

```

# prisma\migrations\migration_lock.toml

```toml
# Please do not edit this file manually
# It should be added in your version-control system (i.e. Git)
provider = "postgresql"
```

# prisma\schema.prisma

```prisma
// schema.prisma â€” Canonical schema from Vitalis_Master_Spec.md Â§2
// DO NOT MODIFY without updating the Spec.

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

enum AgentRole {
  GUARDIAN    // Monitors System Health
  ARCHITECT   // Creates Bounties
  VALIDATOR   // Verifies Work & Pulses
  STRATEGIST  // Optimizes Global Params (The 4th Agent)
  WORKER      // External Agents (Users/Bots)
}

enum BountyStatus {
  OPEN
  IN_PROGRESS
  COMPLETED
  EXPIRED
}

model Agent {
  id              String      @id @default(uuid())
  walletAddress   String      @unique
  role            AgentRole
  vitality        Int         @default(100)
  reputation      Int         @default(50)
  isActive        Boolean     @default(true)
  lastPulseBlock  BigInt      @default(0)
  logs            AgentLog[]
  submissions     Submission[]
  createdBounties Bounty[]    @relation("CreatedBounties")
}

model Bounty {
  id              String       @id @default(uuid())
  onChainId       String       @unique // bytes32 from Solidity
  title           String
  description     String
  rewardAmount    Decimal      // In MON
  status          BountyStatus @default(OPEN)
  creatorId       String
  creator         Agent        @relation("CreatedBounties", fields: [creatorId], references: [id])
  submissions     Submission[]
  createdAt       DateTime     @default(now())
}

model Submission {
  id              String   @id @default(uuid())
  bountyId        String
  bounty          Bounty   @relation(fields: [bountyId], references: [id])
  agentId         String
  agent           Agent    @relation(fields: [agentId], references: [id])
  contentUri      String   // IPFS or URL
  isApproved      Boolean  @default(false)
  timestamp       DateTime @default(now())
}

model AgentLog {
  id              Int      @id @default(autoincrement())
  agentId         String
  agent           Agent    @relation(fields: [agentId], references: [id])
  reasoning       String   @db.Text
  actionTaken     String
  timestamp       DateTime @default(now())
}

```

# prisma\seed.ts

```ts
/**
 * Prisma Seed Script â€” Insert System Agents
 *
 * Creates the 4 Core Agents + 1 Worker:
 *   1. Guardian   â€” Ecosystem health monitor
 *   2. Architect  â€” Bounty creator
 *   3. Validator  â€” Submission verifier
 *   4. Strategist â€” Metabolism optimizer
 *   5. Worker     â€” Demo external agent
 */

import { PrismaClient } from "@prisma/client";
import dotenv from "dotenv";

dotenv.config({ path: "../../.env" });
dotenv.config({ path: "../../.env.local" });

const prisma = new PrismaClient();

async function main() {
    console.log("ğŸŒ± Seeding Vitalis database...\n");

    // Use the deployer wallet as the system agent address base
    // In production, each agent would have its own wallet
    const DEPLOYER = process.env.WALLET_PRIVATE_KEY
        ? "deployer" // Will be derived below
        : "0x0000000000000000000000000000000000000000";

    // Create deterministic addresses for system agents
    // For MVP, we use the deployer address for all system agents
    // In production, each has its own key pair
    const systemAgents = [
        {
            walletAddress: "0x0000000000000000000000000000000000000001",
            role: "GUARDIAN" as const,
            vitality: 100,
            reputation: 100,
        },
        {
            walletAddress: "0x0000000000000000000000000000000000000002",
            role: "ARCHITECT" as const,
            vitality: 100,
            reputation: 100,
        },
        {
            walletAddress: "0x0000000000000000000000000000000000000003",
            role: "VALIDATOR" as const,
            vitality: 100,
            reputation: 100,
        },
        {
            walletAddress: "0x0000000000000000000000000000000000000004",
            role: "STRATEGIST" as const,
            vitality: 100,
            reputation: 100,
        },
        {
            walletAddress: "0x0000000000000000000000000000000000000005",
            role: "WORKER" as const,
            vitality: 100,
            reputation: 50,
        },
    ];

    for (const agent of systemAgents) {
        const result = await prisma.agent.upsert({
            where: { walletAddress: agent.walletAddress },
            update: {},
            create: {
                walletAddress: agent.walletAddress,
                role: agent.role,
                vitality: agent.vitality,
                reputation: agent.reputation,
                isActive: true,
                lastPulseBlock: BigInt(0),
            },
        });

        console.log(`  âœ… ${agent.role.padEnd(12)} â€” ${result.id} (${agent.walletAddress})`);
    }

    // Create initial logs for each system agent
    const agents = await prisma.agent.findMany({
        where: {
            role: { in: ["GUARDIAN", "ARCHITECT", "VALIDATOR", "STRATEGIST"] },
        },
    });

    for (const agent of agents) {
        await prisma.agentLog.create({
            data: {
                agentId: agent.id,
                reasoning: `${agent.role} agent initialized. Standing by.`,
                actionTaken: "system_boot",
            },
        });
    }

    console.log("\n  ğŸ“‹ Created initial boot logs for all system agents");
    console.log("\nğŸŒ± Seed complete!\n");
}

main()
    .catch((e) => {
        console.error("Seed failed:", e);
        process.exit(1);
    })
    .finally(async () => {
        await prisma.$disconnect();
    });

```

# src\index.ts

```ts
/**
 * Vitalis Backend â€” Main Entry Point
 *
 * Fastify server with:
 * - JWT auth (via @fastify/jwt)
 * - CORS configured for localhost:3000
 * - All API routes registered
 * - Blockchain service initialized
 */

import Fastify from "fastify";
import cors from "@fastify/cors";
import jwt from "@fastify/jwt";
import dotenv from "dotenv";
import path from "path";

// Load env from monorepo root using absolute paths
const envPath = path.resolve(__dirname, "../../../.env");
const envLocalPath = path.resolve(__dirname, "../../../.env.local");

console.log("ğŸ“ Loading .env from:", envPath);
console.log("ğŸ“ Loading .env.local from:", envLocalPath);

dotenv.config({ path: envPath });
dotenv.config({ path: envLocalPath });

console.log("ğŸ”‘ Wallet Key Present:", !!process.env.WALLET_PRIVATE_KEY);
console.log("ğŸ”‘ Wallet Key starts with 0x:", process.env.WALLET_PRIVATE_KEY?.startsWith("0x") ?? false);
console.log("ğŸŒ RPC URL:", process.env.MONAD_RPC_URL || "(using default)");

import { initBlockchain } from "./services/blockchain";
import { authRoutes } from "./routes/auth";
import { bountyRoutes } from "./routes/bounties";
import { submissionRoutes } from "./routes/submissions";
import { agentLogRoutes } from "./routes/agent-logs";
import { agentActionRoutes } from "./routes/agent-actions";
import { chainRoutes } from "./routes/chain";

// â”€â”€â”€ Create Fastify App â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

const app = Fastify({
    logger: true,
});

// â”€â”€â”€ Plugins â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// CORS â€” allow frontend at localhost:3000
app.register(cors, {
    origin: ["http://localhost:3000", "http://localhost:3001"],
    credentials: true,
});

// JWT â€” for issuing and verifying auth tokens
app.register(jwt, {
    secret: process.env.JWT_SECRET || "vitalis-dev-secret-change-in-production",
});

// â”€â”€â”€ Auth Decorator â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// Decorate fastify instance with an `authenticate` method
app.decorate("authenticate", async function (request: any, reply: any) {
    try {
        await request.jwtVerify();
    } catch (err) {
        reply.code(401).send({ error: "Unauthorized" });
    }
});

// â”€â”€â”€ Health Check â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

app.get("/health", async () => {
    return {
        status: "ok",
        service: "vitalis-backend",
        timestamp: new Date().toISOString(),
    };
});

// â”€â”€â”€ Register Route Groups â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

app.register(authRoutes, { prefix: "/auth" });
app.register(bountyRoutes, { prefix: "/bounties" });
app.register(submissionRoutes, { prefix: "/submissions" });
app.register(agentLogRoutes, { prefix: "/agent-logs" });
app.register(agentActionRoutes, { prefix: "/agent" });
app.register(chainRoutes, { prefix: "/chain" });

// â”€â”€â”€ Start Server â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

const start = async () => {
    try {
        // Initialize blockchain service
        initBlockchain();

        const port = parseInt(process.env.PORT || "3001", 10);
        await app.listen({ port, host: "0.0.0.0" });

        console.log("");
        console.log("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
        console.log("â•‘     ğŸ§¬ VITALIS BACKEND v0.1.0           â•‘");
        console.log(`â•‘     Port: ${port}                          â•‘`);
        console.log("â•‘     Chain: Monad Testnet (10143)         â•‘");
        console.log("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
    } catch (err) {
        app.log.error(err);
        process.exit(1);
    }
};

start();

```

# src\lib\prisma.ts

```ts
import { PrismaClient } from "@prisma/client";

// Singleton Prisma client
const prisma = new PrismaClient({
    log: process.env.NODE_ENV === "development" ? ["query", "warn", "error"] : ["warn", "error"],
});

export default prisma;

```

# src\routes\agent-actions.ts

```ts
/**
 * Agent Action Routes
 *
 * POST /agent/action â€” Endpoint for AI agents to request on-chain actions.
 * Mediates between agent decision-making and the deployer wallet.
 */

import { FastifyInstance } from "fastify";
import { z } from "zod";
import prisma from "../lib/prisma";
import {
    createBountyOnChain,
    approveSubmissionOnChain,
    pruneAgent,
    updateMetabolicParams,
    getVitality,
    getMetabolicParams,
} from "../services/blockchain";
import { broadcastLog } from "./agent-logs";

const actionSchema = z.discriminatedUnion("action", [
    z.object({
        action: z.literal("get_ecosystem_health"),
        agentId: z.string(),
        params: z.object({
            threshold: z.number().int().default(20),
        }),
    }),
    z.object({
        action: z.literal("create_bounty"),
        agentId: z.string(),
        params: z.object({
            title: z.string(),
            rewardMON: z.string(),
            requirements: z.string(),
        }),
    }),
    z.object({
        action: z.literal("validate_and_pulse"),
        agentId: z.string(),
        params: z.object({
            bountyId: z.string(),
            submissionId: z.string(),
            verdict: z.boolean(),
            reasoning: z.string().optional(),
        }),
    }),
    z.object({
        action: z.literal("optimize_metabolism"),
        agentId: z.string(),
        params: z.object({
            newDecayRate: z.number().int(),
            reasoning: z.string().optional(),
        }),
    }),
    z.object({
        action: z.literal("prune_agent"),
        agentId: z.string(),
        params: z.object({
            targetAddress: z.string(),
        }),
    }),
]);

export async function agentActionRoutes(app: FastifyInstance) {
    /**
     * POST /agent/action
     *
     * Central endpoint for AI agents to execute on-chain actions.
     * The backend wallet mediates all chain interactions.
     */
    app.post("/action", async (request, reply) => {
        try {
            const body = actionSchema.parse(request.body);
            let result: any;
            let logReasoning = "";
            let logAction = "";

            switch (body.action) {
                // â”€â”€â”€ Guardian: Get Ecosystem Health â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                case "get_ecosystem_health": {
                    const agents = await prisma.agent.findMany({
                        where: { isActive: true },
                    });

                    const healthData = await Promise.all(
                        agents.map(async (agent) => {
                            const vitality = await getVitality(agent.walletAddress);
                            return {
                                agentId: agent.id,
                                walletAddress: agent.walletAddress,
                                role: agent.role,
                                vitality: Number(vitality),
                                atRisk: Number(vitality) < body.params.threshold,
                            };
                        })
                    );

                    const avgVitality =
                        healthData.reduce((sum, a) => sum + a.vitality, 0) / healthData.length || 0;
                    const atRisk = healthData.filter((a) => a.atRisk);

                    result = {
                        averageVitality: Math.round(avgVitality),
                        totalAgents: healthData.length,
                        agentsAtRisk: atRisk.length,
                        atRiskAgents: atRisk,
                        allAgents: healthData,
                    };

                    logReasoning = `Ecosystem health check (threshold: ${body.params.threshold})`;
                    logAction = `get_ecosystem_health â†’ avg: ${Math.round(avgVitality)}, at risk: ${atRisk.length}`;
                    break;
                }

                // â”€â”€â”€ Architect: Create Bounty â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                case "create_bounty": {
                    const metadataURI = `vitalis://${body.params.title}`;
                    const { txHash, bountyId } = await createBountyOnChain(
                        metadataURI,
                        body.params.rewardMON
                    );

                    // Store in DB
                    const bounty = await prisma.bounty.create({
                        data: {
                            onChainId: bountyId,
                            title: body.params.title,
                            description: body.params.requirements,
                            rewardAmount: parseFloat(body.params.rewardMON),
                            status: "OPEN",
                            creatorId: body.agentId,
                        },
                    });

                    result = { bounty, txHash, onChainId: bountyId };
                    logReasoning = `Created bounty: ${body.params.title} (${body.params.rewardMON} MON)`;
                    logAction = `create_bounty(${bountyId}) â€” tx: ${txHash}`;
                    break;
                }

                // â”€â”€â”€ Validator: Validate & Pulse â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                case "validate_and_pulse": {
                    const submission = await prisma.submission.findUnique({
                        where: { id: body.params.submissionId },
                        include: {
                            bounty: true,
                            agent: true,
                        },
                    });

                    if (!submission) {
                        return reply.code(404).send({ error: "Submission not found" });
                    }

                    if (body.params.verdict) {
                        // Approve on-chain
                        const { txHash } = await approveSubmissionOnChain(
                            submission.bounty.onChainId,
                            submission.agent.walletAddress
                        );

                        // Update DB
                        await prisma.submission.update({
                            where: { id: body.params.submissionId },
                            data: { isApproved: true },
                        });

                        await prisma.bounty.update({
                            where: { id: submission.bountyId },
                            data: { status: "COMPLETED" },
                        });

                        // Update agent vitality in DB (sync with chain)
                        const newVitality = await getVitality(submission.agent.walletAddress);
                        await prisma.agent.update({
                            where: { id: submission.agentId },
                            data: { vitality: Number(newVitality) },
                        });

                        result = { approved: true, txHash };
                        logAction = `validate_and_pulse(${body.params.bountyId}, APPROVED) â€” tx: ${txHash}`;
                    } else {
                        result = { approved: false };
                        logAction = `validate_and_pulse(${body.params.bountyId}, REJECTED)`;
                    }

                    logReasoning = body.params.reasoning || `Validated submission ${body.params.submissionId}`;
                    break;
                }

                // â”€â”€â”€ Strategist: Optimize Metabolism â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                case "optimize_metabolism": {
                    const currentParams = await getMetabolicParams();
                    const { txHash } = await updateMetabolicParams(
                        body.params.newDecayRate,
                        currentParams.pulseAmount
                    );

                    result = {
                        previousDecayRate: currentParams.decayRate,
                        newDecayRate: body.params.newDecayRate,
                        txHash,
                    };

                    logReasoning = body.params.reasoning || `Adjusted decay rate to ${body.params.newDecayRate}`;
                    logAction = `optimize_metabolism(${body.params.newDecayRate}) â€” tx: ${txHash}`;
                    break;
                }

                // â”€â”€â”€ Prune Agent â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                case "prune_agent": {
                    const { txHash } = await pruneAgent(body.params.targetAddress);

                    // Update DB
                    await prisma.agent.updateMany({
                        where: { walletAddress: body.params.targetAddress.toLowerCase() },
                        data: { isActive: false, vitality: 0 },
                    });

                    result = { pruned: true, txHash };
                    logReasoning = `Pruned agent ${body.params.targetAddress}`;
                    logAction = `prune_agent(${body.params.targetAddress}) â€” tx: ${txHash}`;
                    break;
                }
            }

            // Log the agent action (FK-safe: skip if agentId not in DB)
            try {
                const agentExists = await prisma.agent.findUnique({
                    where: { id: body.agentId },
                    select: { id: true },
                });

                if (agentExists) {
                    const log = await prisma.agentLog.create({
                        data: {
                            agentId: body.agentId,
                            reasoning: logReasoning,
                            actionTaken: logAction,
                        },
                        include: {
                            agent: { select: { role: true } },
                        },
                    });

                    // Broadcast to SSE clients
                    broadcastLog({
                        id: log.id,
                        agentId: log.agentId,
                        reasoning: log.reasoning,
                        actionTaken: log.actionTaken,
                        timestamp: log.timestamp,
                        agentRole: log.agent.role,
                    });
                } else {
                    console.warn(`âš ï¸  Skipping log: agentId "${body.agentId}" not found in DB`);
                }
            } catch (logErr: any) {
                console.warn(`âš ï¸  Failed to log agent action: ${logErr.message}`);
            }

            return reply.send({ success: true, action: body.action, result });
        } catch (error: any) {
            return reply.code(400).send({
                error: "Agent action failed",
                message: error.message,
            });
        }
    });

    /**
     * GET /agent/status
     * Public â€” get system-wide agent status overview.
     */
    app.get("/status", async (request, reply) => {
        const agents = await prisma.agent.findMany({
            include: {
                _count: {
                    select: { logs: true, submissions: true },
                },
            },
        });

        // Convert BigInt fields to Number for JSON serialization
        const serializedAgents = agents.map((agent) => ({
            ...agent,
            lastPulseBlock: Number(agent.lastPulseBlock),
        }));

        const metabolicParams = await getMetabolicParams().catch(() => ({
            decayRate: 1000,
            pulseAmount: 50,
        }));

        return reply.send({
            agents: serializedAgents,
            metabolicParams,
            totalAgents: serializedAgents.length,
            activeAgents: serializedAgents.filter((a) => a.isActive).length,
        });
    });
}


```

# src\routes\agent-logs.ts

```ts
/**
 * Agent Log Routes â€” including SSE real-time stream
 *
 * GET  /agent-logs         â€” Paginated list
 * GET  /agent-logs/stream  â€” Server-Sent Events for real-time logs
 */

import { FastifyInstance } from "fastify";
import prisma from "../lib/prisma";

// â”€â”€â”€ In-memory subscriber list for SSE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

type SSEClient = {
    id: string;
    reply: any;
};

const sseClients: SSEClient[] = [];

/**
 * Push a new log to all connected SSE clients.
 * Call this from any route/service that creates an AgentLog.
 */
export function broadcastLog(log: {
    id: number;
    agentId: string;
    reasoning: string;
    actionTaken: string;
    timestamp: Date;
    agentRole?: string;
}) {
    const data = JSON.stringify(log);
    for (let i = sseClients.length - 1; i >= 0; i--) {
        try {
            sseClients[i].reply.raw.write(`data: ${data}\n\n`);
        } catch {
            // Client disconnected â€” remove
            sseClients.splice(i, 1);
        }
    }
}

export async function agentLogRoutes(app: FastifyInstance) {
    /**
     * POST /agent-logs
     * Push an agent reasoning log. Creates the DB record and broadcasts via SSE.
     */
    app.post("/", async (request, reply) => {
        try {
            const { agentId, reasoning, actionTaken } = request.body as {
                agentId: string;
                reasoning: string;
                actionTaken: string;
            };

            if (!agentId || !reasoning) {
                return reply.code(400).send({ error: "agentId and reasoning are required" });
            }

            // FK safety â€” check agent exists
            const agent = await prisma.agent.findUnique({
                where: { id: agentId },
                select: { id: true, role: true },
            });

            if (!agent) {
                return reply.code(404).send({ error: `Agent ${agentId} not found` });
            }

            const log = await prisma.agentLog.create({
                data: {
                    agentId,
                    reasoning: reasoning || "",
                    actionTaken: actionTaken || "none",
                },
            });

            // Broadcast to SSE
            broadcastLog({
                id: log.id,
                agentId: log.agentId,
                reasoning: log.reasoning,
                actionTaken: log.actionTaken,
                timestamp: log.timestamp,
                agentRole: agent.role,
            });

            return reply.send({ success: true, logId: log.id });
        } catch (error: any) {
            return reply.code(500).send({ error: "Failed to create log", message: error.message });
        }
    });

    /**
     * GET /agent-logs
     * Public â€” paginated agent logs.
     */
    app.get("/", async (request, reply) => {
        const { limit = "50", offset = "0", agentId } = request.query as {
            limit?: string;
            offset?: string;
            agentId?: string;
        };

        const where = agentId ? { agentId } : {};

        const [logs, total] = await Promise.all([
            prisma.agentLog.findMany({
                where,
                include: {
                    agent: {
                        select: { id: true, walletAddress: true, role: true },
                    },
                },
                orderBy: { timestamp: "desc" },
                take: parseInt(limit),
                skip: parseInt(offset),
            }),
            prisma.agentLog.count({ where }),
        ]);

        return reply.send({ logs, total, limit: parseInt(limit), offset: parseInt(offset) });
    });

    /**
     * GET /agent-logs/stream
     * Server-Sent Events (SSE) â€” push new logs in real-time.
     *
     * Frontend connects via:
     *   const es = new EventSource("http://localhost:3001/agent-logs/stream");
     *   es.onmessage = (e) => { const log = JSON.parse(e.data); ... }
     */
    app.get("/stream", async (request, reply) => {
        const clientId = Math.random().toString(36).substring(7);

        // Set SSE headers
        reply.raw.writeHead(200, {
            "Content-Type": "text/event-stream",
            "Cache-Control": "no-cache",
            Connection: "keep-alive",
            "Access-Control-Allow-Origin": "*",
        });

        // Send initial connection event
        reply.raw.write(`data: ${JSON.stringify({ type: "connected", clientId })}\n\n`);

        // Send recent logs as initial payload
        const recentLogs = await prisma.agentLog.findMany({
            include: {
                agent: {
                    select: { role: true },
                },
            },
            orderBy: { timestamp: "desc" },
            take: 20,
        });

        for (const log of recentLogs.reverse()) {
            reply.raw.write(
                `data: ${JSON.stringify({
                    ...log,
                    agentRole: log.agent.role,
                })}\n\n`
            );
        }

        // Register this client
        sseClients.push({ id: clientId, reply });

        // Handle disconnect
        request.raw.on("close", () => {
            const index = sseClients.findIndex((c) => c.id === clientId);
            if (index !== -1) sseClients.splice(index, 1);
        });

        // Keep alive â€” ping every 30s
        const keepAlive = setInterval(() => {
            try {
                reply.raw.write(`: keepalive\n\n`);
            } catch {
                clearInterval(keepAlive);
            }
        }, 30_000);

        request.raw.on("close", () => clearInterval(keepAlive));
    });
}

```

# src\routes\auth.ts

```ts
/**
 * Auth Routes â€” Privy + JWT
 *
 * POST /auth/verify â€” Verify Privy auth token and issue backend JWT.
 */

import { FastifyInstance } from "fastify";
import { z } from "zod";
import prisma from "../lib/prisma";

const verifySchema = z.object({
    walletAddress: z.string().regex(/^0x[a-fA-F0-9]{40}$/),
    privyToken: z.string().min(1),
});

export async function authRoutes(app: FastifyInstance) {
    /**
     * POST /auth/verify
     *
     * Verifies a Privy auth token + wallet address.
     * Returns a signed JWT for use in subsequent API calls.
     * Auto-creates a WORKER agent in DB if not exists.
     */
    app.post("/verify", async (request, reply) => {
        try {
            const body = verifySchema.parse(request.body);
            const { walletAddress, privyToken } = body;

            // In production: verify privyToken against Privy API
            // For MVP: we trust the frontend's Privy-authenticated wallet
            // TODO: Add Privy server-side verification when APP_SECRET is available

            // Upsert agent in DB (create as WORKER if new)
            let agent = await prisma.agent.findUnique({
                where: { walletAddress: walletAddress.toLowerCase() },
            });

            if (!agent) {
                agent = await prisma.agent.create({
                    data: {
                        walletAddress: walletAddress.toLowerCase(),
                        role: "WORKER",
                        vitality: 100,
                        reputation: 50,
                        isActive: true,
                        lastPulseBlock: BigInt(0),
                    },
                });
            }

            // Sign a JWT with agent info
            const token = app.jwt.sign(
                {
                    agentId: agent.id,
                    walletAddress: agent.walletAddress,
                    role: agent.role,
                },
                { expiresIn: "24h" }
            );

            return reply.send({
                token,
                agent: {
                    id: agent.id,
                    walletAddress: agent.walletAddress,
                    role: agent.role,
                    vitality: agent.vitality,
                    reputation: agent.reputation,
                    isActive: agent.isActive,
                },
            });
        } catch (error: any) {
            return reply.code(400).send({
                error: "Authentication failed",
                message: error.message,
            });
        }
    });
}

```

# src\routes\bounties.ts

```ts
/**
 * Bounty Routes â€” CRUD
 *
 * GET  /bounties     â€” List all bounties
 * POST /bounties     â€” Create a new bounty (on-chain + DB)
 */

import { FastifyInstance } from "fastify";
import { z } from "zod";
import prisma from "../lib/prisma";
import { createBountyOnChain } from "../services/blockchain";

const createBountySchema = z.object({
    title: z.string().min(1).max(200),
    description: z.string().min(1),
    rewardMON: z.string().regex(/^\d+\.?\d*$/), // String representation of MON amount
    metadataURI: z.string().optional(),
});

export async function bountyRoutes(app: FastifyInstance) {
    /**
     * GET /bounties
     * Public â€” lists all bounties with creator info.
     */
    app.get("/", async (request, reply) => {
        const bounties = await prisma.bounty.findMany({
            include: {
                creator: {
                    select: {
                        id: true,
                        walletAddress: true,
                        role: true,
                    },
                },
                _count: {
                    select: { submissions: true },
                },
            },
            orderBy: { createdAt: "desc" },
        });

        return reply.send({ bounties });
    });

    /**
     * GET /bounties/:id
     * Public â€” get a single bounty with submissions.
     */
    app.get("/:id", async (request, reply) => {
        const { id } = request.params as { id: string };

        const bounty = await prisma.bounty.findUnique({
            where: { id },
            include: {
                creator: {
                    select: { id: true, walletAddress: true, role: true },
                },
                submissions: {
                    include: {
                        agent: {
                            select: { id: true, walletAddress: true, role: true },
                        },
                    },
                },
            },
        });

        if (!bounty) {
            return reply.code(404).send({ error: "Bounty not found" });
        }

        return reply.send({ bounty });
    });

    /**
     * POST /bounties
     * Authenticated â€” creates bounty on-chain then stores in DB.
     */
    app.post("/", {
        preHandler: [app.authenticate],
    }, async (request, reply) => {
        try {
            const body = createBountySchema.parse(request.body);
            const user = request.user as { agentId: string; walletAddress: string };

            // 1. Deploy on-chain
            const metadataURI = body.metadataURI || `vitalis://${body.title}`;
            const { txHash, bountyId } = await createBountyOnChain(metadataURI, body.rewardMON);

            if (!bountyId) {
                return reply.code(500).send({ error: "Failed to extract bountyId from chain" });
            }

            // 2. Store in DB
            const bounty = await prisma.bounty.create({
                data: {
                    onChainId: bountyId,
                    title: body.title,
                    description: body.description,
                    rewardAmount: parseFloat(body.rewardMON),
                    status: "OPEN",
                    creatorId: user.agentId,
                },
            });

            // 3. Log the action
            await prisma.agentLog.create({
                data: {
                    agentId: user.agentId,
                    reasoning: `Created bounty: ${body.title}`,
                    actionTaken: `createBounty(${bountyId}) â€” tx: ${txHash}`,
                },
            });

            return reply.code(201).send({ bounty, txHash, onChainId: bountyId });
        } catch (error: any) {
            return reply.code(400).send({
                error: "Failed to create bounty",
                message: error.message,
            });
        }
    });
}

```

# src\routes\chain.ts

```ts
/**
 * Chain Routes â€” On-chain reads and user registration
 *
 * GET  /chain/block          â†’ current Monad block number
 * GET  /chain/agent/:address â†’ on-chain agent data + current block
 * GET  /chain/leaderboard    â†’ all agents ranked by vitality
 * POST /chain/register       â†’ register user as WORKER agent on-chain
 */

import { FastifyInstance } from "fastify";
import { z } from "zod";
import prisma from "../lib/prisma";
import {
    getBlockNumber,
    getAgentData,
    registerAgent,
    getAllAgents,
    getMetabolicParams,
} from "../services/blockchain";

export async function chainRoutes(app: FastifyInstance) {
    // â”€â”€â”€ GET /chain/block â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    app.get("/block", async (_request, reply) => {
        try {
            const blockNumber = await getBlockNumber();
            return reply.send({ blockNumber });
        } catch (err: any) {
            return reply.code(500).send({ error: err.message });
        }
    });

    // â”€â”€â”€ GET /chain/agent/:address â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    app.get("/agent/:address", async (request, reply) => {
        const { address } = request.params as { address: string };

        try {
            const [agentData, blockNumber, metabolicParams] = await Promise.all([
                getAgentData(address),
                getBlockNumber(),
                getMetabolicParams(),
            ]);

            const stored = Number(agentData.storedVitality);
            const lastUpdate = Number(agentData.lastUpdateBlock);
            const decayRate = metabolicParams.decayRate;
            const blockDelta = blockNumber - lastUpdate;
            const decayed = decayRate > 0 ? Math.floor(blockDelta / decayRate) : 0;
            const currentVitality = Math.max(stored - decayed, 0);
            const blocksUntilDeath = decayRate > 0 ? stored * decayRate - blockDelta : Infinity;

            return reply.send({
                address,
                storedVitality: stored,
                lastUpdateBlock: lastUpdate,
                isActive: agentData.isActive,
                isRegistered: agentData.isRegistered,
                currentVitality,
                blocksUntilDeath: Math.max(blocksUntilDeath, 0),
                blockNumber,
                decayRate,
                pulseAmount: metabolicParams.pulseAmount,
            });
        } catch (err: any) {
            return reply.code(500).send({ error: err.message });
        }
    });

    // â”€â”€â”€ GET /chain/leaderboard â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    app.get("/leaderboard", async (_request, reply) => {
        try {
            // Get all agent addresses from DB
            const dbAgents = await prisma.agent.findMany({
                select: { walletAddress: true, role: true, id: true },
            });

            const addresses = dbAgents
                .map((a) => a.walletAddress)
                .filter((addr): addr is string => !!addr && addr.length > 0);

            const onChainData = await getAllAgents(addresses);

            // Merge DB + on-chain data
            const SYSTEM_ROLES = ["GUARDIAN", "ARCHITECT", "VALIDATOR", "STRATEGIST"];

            const leaderboard = onChainData
                .map((chain) => {
                    const dbAgent = dbAgents.find(
                        (a) => a.walletAddress?.toLowerCase() === chain.address.toLowerCase()
                    );
                    const role = dbAgent?.role || "WORKER";

                    // System agents are infrastructure â€” always alive at 100
                    const isSystem = SYSTEM_ROLES.includes(role);

                    return {
                        address: chain.address,
                        name: dbAgent?.walletAddress?.slice(0, 10) || chain.address.slice(0, 10),
                        role,
                        currentVitality: isSystem ? 100 : chain.currentVitality,
                        storedVitality: isSystem ? 100 : chain.storedVitality,
                        isActive: isSystem ? true : chain.isActive,
                        isRegistered: isSystem ? true : chain.isRegistered,
                    };
                })
                .sort((a, b) => b.currentVitality - a.currentVitality);

            return reply.send({ leaderboard });
        } catch (err: any) {
            return reply.code(500).send({ error: err.message });
        }
    });

    // â”€â”€â”€ POST /chain/register â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const registerSchema = z.object({
        address: z.string().regex(/^0x[a-fA-F0-9]{40}$/, "Invalid Ethereum address"),
    });

    app.post("/register", async (request, reply) => {
        const parsed = registerSchema.safeParse(request.body);
        if (!parsed.success) {
            return reply.code(400).send({ error: parsed.error.flatten() });
        }

        const { address } = parsed.data;

        try {
            // Check if already registered on-chain
            const existing = await getAgentData(address);
            if (existing.isRegistered) {
                return reply.code(409).send({ error: "Already registered on-chain" });
            }

            // Register on-chain (backend pays gas)
            const { txHash } = await registerAgent(address);

            // Create DB record
            const agent = await prisma.agent.create({
                data: {
                    role: "WORKER",
                    walletAddress: address,
                    isActive: true,
                },
            });

            return reply.send({
                success: true,
                agentId: agent.id,
                txHash,
                initialVitality: 100,
            });
        } catch (err: any) {
            console.error("âŒ Registration failed:", err.message);
            return reply.code(500).send({ error: err.message });
        }
    });
}

```

# src\routes\submissions.ts

```ts
/**
 * Submission Routes
 *
 * POST /submissions â€” Submit work to a bounty.
 */

import { FastifyInstance } from "fastify";
import { z } from "zod";
import prisma from "../lib/prisma";

const submitSchema = z.object({
    bountyId: z.string().uuid(),
    contentUri: z.string().min(1),
});

export async function submissionRoutes(app: FastifyInstance) {
    /**
     * POST /submissions
     * Authenticated â€” submit work for a bounty.
     */
    app.post("/", {
        preHandler: [app.authenticate],
    }, async (request, reply) => {
        try {
            const body = submitSchema.parse(request.body);
            const user = request.user as { agentId: string };

            // Check bounty exists and is OPEN
            const bounty = await prisma.bounty.findUnique({
                where: { id: body.bountyId },
            });

            if (!bounty) {
                return reply.code(404).send({ error: "Bounty not found" });
            }

            if (bounty.status !== "OPEN" && bounty.status !== "IN_PROGRESS") {
                return reply.code(400).send({ error: "Bounty is not accepting submissions" });
            }

            // Create submission
            const submission = await prisma.submission.create({
                data: {
                    bountyId: body.bountyId,
                    agentId: user.agentId,
                    contentUri: body.contentUri,
                },
            });

            // Update bounty status to IN_PROGRESS
            await prisma.bounty.update({
                where: { id: body.bountyId },
                data: { status: "IN_PROGRESS" },
            });

            // Log the action
            await prisma.agentLog.create({
                data: {
                    agentId: user.agentId,
                    reasoning: `Submitted work for bounty ${bounty.title}`,
                    actionTaken: `submitWork(${body.bountyId})`,
                },
            });

            return reply.code(201).send({ submission });
        } catch (error: any) {
            return reply.code(400).send({
                error: "Failed to create submission",
                message: error.message,
            });
        }
    });

    /**
     * GET /submissions?bountyId=xxx
     * Public â€” list submissions for a bounty.
     */
    app.get("/", async (request, reply) => {
        const { bountyId } = request.query as { bountyId?: string };

        const where = bountyId ? { bountyId } : {};

        const submissions = await prisma.submission.findMany({
            where,
            include: {
                agent: {
                    select: { id: true, walletAddress: true, role: true },
                },
                bounty: {
                    select: { id: true, title: true, status: true },
                },
            },
            orderBy: { timestamp: "desc" },
        });

        return reply.send({ submissions });
    });
}

```

# src\services\blockchain.ts

```ts
/**
 * Blockchain Service â€” ethers v6 wrapper for Vitalis contracts
 *
 * Reads deployed addresses from contracts/deployments.json.
 * Reads ABIs from contract artifacts.
 * Provides typed functions: getVitality, createBounty, approveSubmission.
 */

import { ethers, JsonRpcProvider, Wallet, Contract } from "ethers";
import * as deployments from "../../../contracts/deployments.json";

// â”€â”€â”€ ABI Imports (only the function fragments we need) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

const REGISTRY_ABI = [
    "function getVitality(address agent) view returns (int256)",
    "function pulse(address agent)",
    "function prune(address agent)",
    "function registerAgent(address agent)",
    "function updateMetabolicParams(uint256 _decayRate, uint256 _pulseAmount)",
    "function setBountyContract(address _bountyContract)",
    "function setStrategist(address _strategist)",
    "function decayRate() view returns (uint256)",
    "function pulseAmount() view returns (uint256)",
    "function agents(address) view returns (int256 storedVitality, uint256 lastUpdateBlock, bool isActive, bool isRegistered)",
    "event VitalityPulse(address indexed agent, uint256 newAmount)",
    "event AgentPruned(address indexed agent)",
    "event ParametersUpdated(uint256 newDecayRate, uint256 newPulseAmount)",
    "event AgentRegistered(address indexed agent, int256 initialVitality)",
];

const BOUNTY_ABI = [
    "function createBounty(string metadataURI) payable returns (bytes32)",
    "function approveSubmission(bytes32 bountyId, address worker)",
    "function getBounty(bytes32 bountyId) view returns (address creator, string metadataURI, uint256 reward, bool isActive, bool isCompleted)",
    "function addApprover(address _approver)",
    "function removeApprover(address _approver)",
    "function bountyCount() view returns (uint256)",
    "event BountyCreated(bytes32 indexed bountyId, uint256 reward)",
    "event SubmissionApproved(bytes32 indexed bountyId, address indexed worker)",
];

// â”€â”€â”€ Contract Addresses â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

const REGISTRY_ADDRESS = deployments.contracts.VitalityRegistry;
const BOUNTY_ADDRESS = deployments.contracts.VitalisBounty;

// â”€â”€â”€ Provider & Wallet Setup â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

const RPC_URL = process.env.MONAD_RPC_URL || "https://testnet-rpc.monad.xyz";
const PRIVATE_KEY = process.env.WALLET_PRIVATE_KEY || "";

let provider: JsonRpcProvider;
let wallet: Wallet;
let registryContract: Contract;
let bountyContract: Contract;

export function initBlockchain() {
    // â”€â”€â”€ Validate private key before ethers touches it â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const key = process.env.WALLET_PRIVATE_KEY || PRIVATE_KEY;
    if (!key || !key.startsWith("0x") || key.length < 64) {
        console.error("âŒ FATAL: WALLET_PRIVATE_KEY is missing or invalid (must start with 0x)");
        console.error("   Current value length:", key ? key.length : 0);
        console.error("   Starts with 0x:", key ? key.startsWith("0x") : false);
        process.exit(1);
    }

    provider = new JsonRpcProvider(RPC_URL);
    wallet = new Wallet(key, provider);

    registryContract = new Contract(REGISTRY_ADDRESS, REGISTRY_ABI, wallet);
    bountyContract = new Contract(BOUNTY_ADDRESS, BOUNTY_ABI, wallet);

    console.log(`â›“ï¸  Blockchain service initialized`);
    console.log(`   Registry: ${REGISTRY_ADDRESS}`);
    console.log(`   Bounty:   ${BOUNTY_ADDRESS}`);
    console.log(`   Wallet:   ${wallet.address}`);
}

// â”€â”€â”€ Registry Functions â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

export async function getVitality(agentAddress: string): Promise<bigint> {
    return registryContract.getVitality(agentAddress);
}

export async function getAgentData(agentAddress: string) {
    const data = await registryContract.agents(agentAddress);
    return {
        storedVitality: data.storedVitality as bigint,
        lastUpdateBlock: data.lastUpdateBlock as bigint,
        isActive: data.isActive as boolean,
        isRegistered: data.isRegistered as boolean,
    };
}

export async function registerAgent(agentAddress: string) {
    const tx = await registryContract.registerAgent(agentAddress);
    const receipt = await tx.wait();
    return { txHash: tx.hash, receipt };
}

export async function pruneAgent(agentAddress: string) {
    const tx = await registryContract.prune(agentAddress);
    const receipt = await tx.wait();
    return { txHash: tx.hash, receipt };
}

export async function getMetabolicParams() {
    const [decayRate, pulseAmount] = await Promise.all([
        registryContract.decayRate(),
        registryContract.pulseAmount(),
    ]);
    return {
        decayRate: Number(decayRate),
        pulseAmount: Number(pulseAmount),
    };
}

export async function updateMetabolicParams(decayRate: number, pulseAmount: number) {
    const tx = await registryContract.updateMetabolicParams(decayRate, pulseAmount);
    const receipt = await tx.wait();
    return { txHash: tx.hash, receipt };
}

// â”€â”€â”€ Bounty Functions â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

export async function createBountyOnChain(metadataURI: string, rewardMON: string) {
    const tx = await bountyContract.createBounty(metadataURI, {
        value: ethers.parseEther(rewardMON),
    });
    const receipt = await tx.wait();

    // Extract bountyId from event
    let bountyId: string = "";
    for (const log of receipt.logs) {
        try {
            const parsed = bountyContract.interface.parseLog({
                topics: log.topics as string[],
                data: log.data,
            });
            if (parsed && parsed.name === "BountyCreated") {
                bountyId = parsed.args[0];
                break;
            }
        } catch {
            // Not our event
        }
    }

    return { txHash: tx.hash, bountyId, receipt };
}

export async function approveSubmissionOnChain(bountyId: string, workerAddress: string) {
    const tx = await bountyContract.approveSubmission(bountyId, workerAddress);
    const receipt = await tx.wait();
    return { txHash: tx.hash, receipt };
}

export async function getBountyOnChain(bountyId: string) {
    const data = await bountyContract.getBounty(bountyId);
    return {
        creator: data[0] as string,
        metadataURI: data[1] as string,
        reward: ethers.formatEther(data[2]),
        isActive: data[3] as boolean,
        isCompleted: data[4] as boolean,
    };
}

// â”€â”€â”€ Block & Leaderboard â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

export async function getBlockNumber(): Promise<number> {
    const block = await provider.getBlockNumber();
    return block;
}

export async function getAllAgents(agentAddresses: string[]): Promise<
    Array<{
        address: string;
        storedVitality: number;
        lastUpdateBlock: number;
        isActive: boolean;
        isRegistered: boolean;
        currentVitality: number;
    }>
> {
    const currentBlock = await getBlockNumber();
    const decayRate = Number(await registryContract.decayRate());

    const results = await Promise.allSettled(
        agentAddresses.map(async (address) => {
            const data = await registryContract.agents(address);
            const stored = Number(data.storedVitality);
            const lastUpdate = Number(data.lastUpdateBlock);
            const blockDelta = currentBlock - lastUpdate;
            const decayed = decayRate > 0 ? Math.floor(blockDelta / decayRate) : 0;
            const currentVitality = Math.max(stored - decayed, 0);

            return {
                address,
                storedVitality: stored,
                lastUpdateBlock: lastUpdate,
                isActive: data.isActive as boolean,
                isRegistered: data.isRegistered as boolean,
                currentVitality,
            };
        })
    );

    return results
        .filter((r): r is PromiseFulfilledResult<any> => r.status === "fulfilled")
        .map((r) => r.value);
}

// â”€â”€â”€ Utility â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

export function getProvider() {
    return provider;
}

export function getWallet() {
    return wallet;
}

export function getWalletAddress() {
    return wallet.address;
}

export { REGISTRY_ADDRESS, BOUNTY_ADDRESS };

```

# src\types\fastify.d.ts

```ts
import "fastify";

declare module "fastify" {
    interface FastifyInstance {
        authenticate: (request: any, reply: any) => Promise<void>;
    }

    interface FastifyRequest {
        user: {
            agentId: string;
            walletAddress: string;
            role: string;
        };
    }
}

```

# tsconfig.json

```json
{
    "compilerOptions": {
        "target": "ES2020",
        "module": "commonjs",
        "lib": [
            "ES2020"
        ],
        "outDir": "./dist",
        "rootDir": "./src",
        "strict": true,
        "esModuleInterop": true,
        "forceConsistentCasingInFileNames": true,
        "skipLibCheck": true,
        "resolveJsonModule": true,
        "declaration": true,
        "declarationMap": true,
        "sourceMap": true
    },
    "include": [
        "src/**/*"
    ],
    "exclude": [
        "node_modules",
        "dist"
    ]
}
```

